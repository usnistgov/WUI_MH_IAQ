"""
Plotting Utility Functions for NIST WUI MH IAQ Analysis

This module provides common plotting functions and configurations used
across multiple analysis scripts in the NIST WUI MH IAQ repository.

Functions:
    - get_script_metadata: Get script name and timestamp for plot annotations
    - create_standard_figure: Create standardized Bokeh figure
    - apply_text_formatting: Apply consistent text formatting to plots
    - configure_legend: Configure legend with standard settings
    - add_event_markers: Add vertical lines for experiment events

Constants:
    - POLLUTANT_COLORS: Color palette for different PM sizes
    - INSTRUMENT_COLORS: Color palettes for different instruments
    - TEXT_CONFIG: Standard text formatting configuration

Author: Nathan Lima
Date: 2024-2025
"""

import datetime
import inspect
import os
from bokeh.plotting import figure
from bokeh.models import Range1d, Div, Span, Label


# Color palettes for different instruments
INSTRUMENT_COLORS = {
    'AeroTrakB': ["#f8aa39", "#f1ae58", "#e8b274", "#ddb78d", "#d0bba7", "#c0c0c0"],
    'AeroTrakK': ["#f8aa39", "#f1ae58", "#e8b274", "#ddb78d", "#d0bba7", "#c0c0c0"],
    'QuantAQB': ["#080be5", "#0068ff", "#0093ff", "#00b4ff", "#00d1d2", "#00eb7f", "#29ff06"],
    'QuantAQK': ["#080be5", "#0068ff", "#0093ff", "#00b4ff", "#00d1d2", "#00eb7f", "#29ff06"],
    'SMPS': ["#ff0000", "#ff3333", "#ff6666", "#ff9999"],
    'DustTrak': ["#8B4513", "#A0522D", "#D2691E"],
    'PurpleAir': ["#9370DB", "#BA55D3", "#DA70D6"],
    'MiniAMS': ["#FF1493", "#FF69B4", "#FFB6C1", "#FFC0CB"],
}

# Color mapping for different PM pollutants
POLLUTANT_COLORS = {
    'PM0.5': '#1f77b4',
    'PM1': '#ff7f0e',
    'PM2.5': '#2ca02c',
    'PM3': '#d62728',
    'PM5': '#9467bd',
    'PM10': '#8c564b',
    'PM15': '#e377c2',
    'PM25': '#7f7f7f',
    'Organic': '#bcbd22',
    'Nitrate': '#17becf',
    'Sulfate': '#FF6347',
    'Ammonium': '#FFD700',
    'Chloride': '#00CED1',
}

# Standard text formatting configuration
TEXT_CONFIG = {
    'title_font_size': '16pt',
    'axis_label_font_size': '14pt',
    'axis_tick_font_size': '12pt',
    'legend_label_font_size': '11pt',
}


def get_script_metadata():
    """
    Get script name and execution timestamp for plot annotations.

    Returns:
    --------
    str
        Formatted string with script name and timestamp

    Examples:
    ---------
    >>> metadata = get_script_metadata()
    >>> print(metadata)
    Generated by: my_script.py | Date: 2024-01-15 14:30:00

    Notes:
    ------
    - Uses inspect module to determine calling script name
    - Falls back to generic name if script name cannot be determined
    - Timestamp format: YYYY-MM-DD HH:MM:SS
    """
    try:
        current_frame = inspect.currentframe()
        module = inspect.getmodule(current_frame) if current_frame else None
        if module and hasattr(module, '__file__') and module.__file__:
            script_name = os.path.basename(module.__file__)
        else:
            # Try to get from caller's frame
            caller_frame = inspect.currentframe().f_back
            if caller_frame:
                caller_module = inspect.getmodule(caller_frame)
                if caller_module and hasattr(caller_module, '__file__'):
                    script_name = os.path.basename(caller_module.__file__)
                else:
                    script_name = "analysis_script.py"
            else:
                script_name = "analysis_script.py"
    except (NameError, AttributeError, TypeError):
        script_name = "analysis_script.py"

    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return f"Generated by: {script_name} | Date: {timestamp}"


def create_standard_figure(
    title,
    x_axis_label="Time Since Garage Closed (hours)",
    y_axis_label="Concentration",
    y_axis_type="log",
    x_range=None,
    y_range=None,
    width=800,
    height=600,
    tools=None,
    tooltips=None
):
    """
    Create a standardized Bokeh figure with common settings.

    Parameters:
    -----------
    title : str
        Figure title
    x_axis_label : str, optional
        X-axis label (default: "Time Since Garage Closed (hours)")
    y_axis_label : str, optional
        Y-axis label (default: "Concentration")
    y_axis_type : str, optional
        Y-axis type: "linear" or "log" (default: "log")
    x_range : tuple or Range1d, optional
        X-axis range, e.g., (-1, 4) or Range1d(-1, 4)
        Default is None (auto range)
    y_range : tuple or Range1d, optional
        Y-axis range, e.g., (1e-4, 1e5) or Range1d(1e-4, 1e5)
        Default is None (auto range for linear, 1e-4 to 1e5 for log)
    width : int, optional
        Figure width in pixels (default: 800)
    height : int, optional
        Figure height in pixels (default: 600)
    tools : list of str, optional
        List of tool names to include
        Default: ["pan", "hover", "box_zoom", "wheel_zoom", "reset", "save"]
    tooltips : list of tuples, optional
        Tooltip specifications
        Default: [("X", "$x{0.2f}"), ("Y", "$y{0.2e}")]

    Returns:
    --------
    bokeh.plotting.figure
        Configured Bokeh figure object

    Examples:
    ---------
    >>> fig = create_standard_figure("PM2.5 Concentrations")
    >>> fig.line([0, 1, 2], [10, 20, 15], legend_label="Sensor A")

    >>> fig = create_standard_figure(
    ...     "Linear Plot",
    ...     y_axis_type="linear",
    ...     x_range=(-1, 4),
    ...     y_range=(0, 100)
    ... )

    Notes:
    ------
    - Logarithmic y-axis useful for wide concentration ranges
    - Grid lines are semi-transparent light gray
    - Default tools provide interactive exploration capabilities
    """
    # Set default tools
    if tools is None:
        tools = ["pan", "hover", "box_zoom", "wheel_zoom", "reset", "save"]

    # Set default tooltips
    if tooltips is None:
        if y_axis_type == "log":
            tooltips = [("X", "$x{0.2f}"), ("Y", "$y{0.2e}")]
        else:
            tooltips = [("X", "$x{0.2f}"), ("Y", "$y{0.2f}")]

    # Create figure
    p = figure(
        title=title,
        x_axis_label=x_axis_label,
        y_axis_label=y_axis_label,
        y_axis_type=y_axis_type,
        width=width,
        height=height,
        tooltips=tooltips,
        tools=",".join(tools),
    )

    # Set axis ranges
    if x_range is not None:
        if isinstance(x_range, tuple):
            p.x_range = Range1d(*x_range)
        else:
            p.x_range = x_range

    if y_range is not None:
        if isinstance(y_range, tuple):
            p.y_range = Range1d(*y_range)
        else:
            p.y_range = y_range
    elif y_axis_type == "log":
        # Default log range
        p.y_range = Range1d(1e-4, 1e5)

    # Configure grid
    p.xgrid.grid_line_color = "lightgray"
    p.xgrid.grid_line_alpha = 0.6
    p.ygrid.grid_line_color = "lightgray"
    p.ygrid.grid_line_alpha = 0.6

    # Apply text formatting
    apply_text_formatting(p)

    return p


def apply_text_formatting(plot_object, config=None):
    """
    Apply consistent text formatting to a Bokeh plot.

    Parameters:
    -----------
    plot_object : bokeh.plotting.figure
        Bokeh figure to format
    config : dict, optional
        Custom text configuration dictionary
        Default uses TEXT_CONFIG

    Returns:
    --------
    bokeh.plotting.figure
        Plot with applied text formatting

    Examples:
    ---------
    >>> from bokeh.plotting import figure
    >>> p = figure()
    >>> p = apply_text_formatting(p)

    >>> custom_config = {'title_font_size': '20pt'}
    >>> p = apply_text_formatting(p, config=custom_config)

    Notes:
    ------
    - Modifies plot object in place
    - Also returns the plot object for method chaining
    """
    if config is None:
        config = TEXT_CONFIG

    # Apply title formatting
    if 'title_font_size' in config:
        plot_object.title.text_font_size = config['title_font_size']

    # Apply axis label formatting
    if 'axis_label_font_size' in config:
        plot_object.xaxis.axis_label_text_font_size = config['axis_label_font_size']
        plot_object.yaxis.axis_label_text_font_size = config['axis_label_font_size']

    # Apply tick label formatting
    if 'axis_tick_font_size' in config:
        plot_object.xaxis.major_label_text_font_size = config['axis_tick_font_size']
        plot_object.yaxis.major_label_text_font_size = config['axis_tick_font_size']

    # Apply legend formatting if legend exists
    if hasattr(plot_object, 'legend') and plot_object.legend:
        if 'legend_label_font_size' in config:
            plot_object.legend.label_text_font_size = config['legend_label_font_size']

    return plot_object


def configure_legend(plot_object, location='top_right', click_policy='hide',
                     background_fill_alpha=0.7, **kwargs):
    """
    Configure legend with standard settings.

    Parameters:
    -----------
    plot_object : bokeh.plotting.figure
        Bokeh figure with legend
    location : str, optional
        Legend location: 'top_left', 'top_right', 'bottom_left', 'bottom_right',
        'top_center', 'bottom_center', 'center_left', 'center_right'
        Default: 'top_right'
    click_policy : str, optional
        Click behavior: 'hide', 'mute', or None
        Default: 'hide'
    background_fill_alpha : float, optional
        Legend background transparency (0=transparent, 1=opaque)
        Default: 0.7
    **kwargs : dict
        Additional legend properties

    Returns:
    --------
    bokeh.plotting.figure
        Plot with configured legend

    Examples:
    ---------
    >>> from bokeh.plotting import figure
    >>> p = figure()
    >>> p.line([1, 2, 3], [1, 2, 3], legend_label="Data")
    >>> configure_legend(p, location='bottom_left', click_policy='mute')

    Notes:
    ------
    - click_policy='hide' allows hiding series by clicking legend
    - click_policy='mute' grays out series instead of hiding
    """
    if hasattr(plot_object, 'legend') and plot_object.legend:
        plot_object.legend.location = location
        plot_object.legend.click_policy = click_policy
        plot_object.legend.background_fill_alpha = background_fill_alpha

        # Apply any additional kwargs
        for key, value in kwargs.items():
            setattr(plot_object.legend, key, value)

    return plot_object


def add_event_markers(plot_object, events, y_range=None):
    """
    Add vertical lines and labels for experimental events.

    Parameters:
    -----------
    plot_object : bokeh.plotting.figure
        Bokeh figure to add markers to
    events : dict
        Dictionary mapping event names to x-coordinates (time values)
        Example: {'Garage Closed': 0, 'CR Boxes On': 1.5}
    y_range : tuple, optional
        Y-range for vertical lines, e.g., (1e-4, 1e5)
        If None, uses plot's y_range

    Returns:
    --------
    bokeh.plotting.figure
        Plot with added event markers

    Examples:
    ---------
    >>> from bokeh.plotting import figure
    >>> p = figure(y_axis_type='log')
    >>> events = {'Start': 0, 'Intervention': 2}
    >>> add_event_markers(p, events, y_range=(1e-4, 1e5))

    Notes:
    ------
    - First event uses solid line, subsequent events use dashed lines
    - Labels positioned to avoid overlap
    - Automatically adds to legend
    """
    if y_range is None:
        # Try to get from plot's y_range
        if hasattr(plot_object.y_range, 'start') and hasattr(plot_object.y_range, 'end'):
            y_min = plot_object.y_range.start
            y_max = plot_object.y_range.end
        else:
            y_min, y_max = 1e-4, 1e5
    else:
        y_min, y_max = y_range

    # Position labels at different heights to avoid overlap
    label_positions = [y_max / 10, y_max / 100, y_max / 1000]

    for idx, (event_name, event_time) in enumerate(events.items()):
        # Choose line style (first is solid, others dashed)
        line_dash = 'solid' if idx == 0 else 'dashed'

        # Add vertical line
        plot_object.line(
            x=[event_time, event_time],
            y=[y_min, y_max],
            line_color='black',
            line_width=2,
            legend_label=event_name,
            line_dash=line_dash,
        )

        # Add label
        label_y = label_positions[idx % len(label_positions)]
        text_align = 'right' if idx == 0 else 'left'

        plot_object.text(
            x=[event_time],
            y=[label_y],
            text=[event_name],
            text_align=text_align,
            text_baseline='middle',
            text_color='black',
            text_font_size='10pt',
        )

    return plot_object


def create_metadata_div(content, width=800):
    """
    Create a Div element with metadata for plot annotations.

    Parameters:
    -----------
    content : str or dict
        If str: HTML content to display
        If dict: Dictionary of key-value pairs to format
    width : int, optional
        Width of the Div in pixels (default: 800)

    Returns:
    --------
    bokeh.models.Div
        Div element with formatted metadata

    Examples:
    ---------
    >>> div = create_metadata_div("This is my plot")

    >>> metadata = {'Burn': 'burn1', 'Instruments': 'AeroTrak, QuantAQ'}
    >>> div = create_metadata_div(metadata)

    >>> script_info = get_script_metadata()
    >>> div = create_metadata_div(f"<small>{script_info}</small>")
    """
    if isinstance(content, dict):
        # Format dictionary as HTML
        lines = [f"<b>{key}:</b> {value}" for key, value in content.items()]
        html_content = f"<p>{' | '.join(lines)}</p>"
    else:
        html_content = content if content.startswith('<') else f"<p>{content}</p>"

    return Div(text=html_content, width=width)


def get_color_for_pollutant(pollutant_name):
    """
    Get standard color for a pollutant type.

    Parameters:
    -----------
    pollutant_name : str
        Pollutant name (e.g., 'PM2.5', 'PM10', 'Organic')

    Returns:
    --------
    str
        Hex color code

    Examples:
    ---------
    >>> get_color_for_pollutant('PM2.5')
    '#2ca02c'

    >>> get_color_for_pollutant('PM10')
    '#8c564b'

    Notes:
    ------
    - Returns default color if pollutant not in POLLUTANT_COLORS
    """
    return POLLUTANT_COLORS.get(pollutant_name, '#333333')


def get_color_palette_for_instrument(instrument_name):
    """
    Get color palette for an instrument.

    Parameters:
    -----------
    instrument_name : str
        Instrument name (e.g., 'AeroTrakB', 'QuantAQB', 'SMPS')

    Returns:
    --------
    list of str
        List of hex color codes

    Examples:
    ---------
    >>> colors = get_color_palette_for_instrument('AeroTrakB')
    >>> len(colors)
    6

    >>> colors = get_color_palette_for_instrument('SMPS')
    >>> len(colors)
    4

    Notes:
    ------
    - Returns default grayscale palette if instrument not found
    """
    return INSTRUMENT_COLORS.get(
        instrument_name,
        ['#000000', '#333333', '#666666', '#999999', '#CCCCCC']
    )
